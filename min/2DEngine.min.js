class Collideable{x;y;width;height;constructor(x,y,width,height){this.x=x;this.y=y;this.width=width;this.height=height}}class Tile extends Collideable{color;constructor(x,y,width,height,color="#000000"){super(x,y,width,height);this.color=color}getColor(){return this.color}setColor(hex){if(hex.match(/\#(\d{6}|\d{3})/gim))this.color=hex}}class EntityInfo{position;motion;id;constructor(position,motion,id){this.position=position;this.motion=motion;this.id=id}}class Vector2{x;y;constructor(x,y){this.x=x;this.y=y}}class Entity extends Collideable{id;position;motion;onGround=false;entityTickBase(){}constructor(x,y,width,height,entityData){super(x,y,width,height);this.id=entityData.id;this.position={current:entityData.position,old:entityData.position,};this.motion=entityData.motion}}class AIEntity extends Entity{}class Physics{gravity=0.08;airFriction=0.003;groundFriction=0.03;verticalFriction=0.01;checksPerCollision=6;slideFriction=0.05;maxSpeed=2;terminalVelocity=3;game;constructor(game){this.game=game}getTileAt(x,y){return this.game.tiles.find((tile)=>tile.x<=x&&tile.x+tile.width>=x&&tile.y<=y&&tile.y+tile.height>=y)}updatePosition(entity){entity.motion.y-=this.gravity;this.game.tiles.forEach((tile)=>this.collide(entity,tile));let temp=entity.position.current.x;entity.position.current.x+=entity.motion.x;entity.position.old.x=temp;temp=entity.position.current.y;entity.position.current.y+=entity.motion.y;entity.position.old.y=temp}isInside(box1,box2,deltaX,deltaY){return(box1.position.current.x+box1.width+deltaX>=box2.x&&box1.position.current.x+deltaX<=box2.x+box2.width&&box1.position.current.y+box1.height+deltaY>=box2.y&&box1.position.current.y+deltaY<=box2.y+box2.height)}collide(box1,box2){let A=[box1.position.current.x,box1.position.current.y,box1.width,box1.height,];let B=[box2.x,box2.y,box2.width,box2.height];let deltaX=box1.position.current.x-box1.position.old.x;let deltaY=box1.position.current.y-box1.position.old.y;if(this.isInside(box1,box2,deltaX,deltaY)){if(Math.abs(A[0]-B[0])-A[2]-B[2]>Math.abs(A[1]-B[1]+deltaX)-A[3]-B[3]&&(A[0]+A[2]-10<=B[0]||A[0]>=B[0]+B[2]+10)){return["right",box2]}else{if(A[1]<B[1])return["top",box2];return["bottom",box2]}}return["none",box2]}}const levels=[[new Tile(0,0,1000,100),new Tile(500,100,20,75),new Tile(700,150,20,1000),new Tile(900,100,100,100),new Tile(1100,200,120,25),new Tile(1400,200,200,50),new Tile(1900,50,200,50),new Tile(2200,100,500,50),new Tile(2900,100,500,50),],[new Tile(0,0,400,100),new Tile(600,0,20,100),new Tile(750,0,20,200),new Tile(1000,10,340,30),new Tile(1500,100,250,40),new Tile(1500,200,175,40),new Tile(1900,200,500,20),new Tile(2675,0,100,100),new Tile(2925,0,1200,100),new Tile(3150,100,20,85),new Tile(3150,300,20,400),new Tile(3300,175,20,600),new Tile(3425,100,20,70),],];class BaseGame{task;physics;entities=[];tiles=[];tickListener;tickBase;constructor(entities,tiles){this.physics=new Physics(this);this.entities=entities;this.tiles=tiles;this.tickListener=()=>{}}start(){this.tickBase=setInterval(()=>{this.entities.forEach((entity)=>entity.entityTickBase());this.tickListener(this)},1)}onTick(callback){this.tickListener=callback}end(){clearInterval(this.tickBase)}}
