window.onerror = (e, u, l) => alert(e + ":" + l);
class Collideable {
	/** @type {number} */
	x;
	/** @type {number} */
	y;
	/** @type {number} */
	width;
	/** @type {number} */
	height;

	/**
	 *
	 * @param {number} x
	 * @param {number} y
	 * @param {number} width
	 * @param {number} height
	 */
	constructor(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}
}

class Tile extends Collideable {
	/**
	 * @type {string}
	 * @private
	 */
	color;

	/**
	 *
	 * @param {number} x
	 * @param {number} y
	 * @param {number} width
	 * @param {number} height
	 * @param {?string} color
	 */
	constructor(x, y, width, height, color = "#000000") {
		super(x, y, width, height);
		this.color = color;
	}

	getColor() {
		return this.color;
	}

	/**
	 * @param {string} hex
	 */
	setColor(hex) {
		if (hex.match(/\#(\d{6}|\d{3})/gim)) this.color = hex;
	}
}

class EntityInfo {
	position;
	motion;
	id;

	/**
	 *
	 * @param {Vector2} position
	 * @param {Vector2} motion
	 * @param {number} id
	 */
	constructor(position, motion, id) {
		this.position = position;
		this.motion = motion;
		this.id = id;
	}
}

class Vector2 {
	x;
	y;

	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}

class Entity extends Collideable {
	/** @type {number} */
	id;

	/** @type {{current: Vector2, old: Vector2}} */
	position;

	/** @type {Vector2} */
	motion;

	/** @type {boolean} */
	onGround = false;

	entityTickBase() {}

	/**
	 *
	 * @param {number} x
	 * @param {number} y
	 * @param {number} width
	 * @param {number} height
	 * @param {EntityInfo} entityData
	 */
	constructor(x, y, width, height, entityData) {
		super(x, y, width, height);
		this.id = entityData.id;
		this.position = {
			current: entityData.position,
			old: entityData.position,
		};
		this.motion = entityData.motion;
	}
}

class AIEntity extends Entity {}

class Physics {
	gravity = 0.08;
	airFriction = 0.003;
	groundFriction = 0.03;
	verticalFriction = 0.01;
	checksPerCollision = 6;
	slideFriction = 0.05;
	maxSpeed = 2;
	terminalVelocity = 3;

	/** @type {BaseGame} */
	game;

	constructor(game) {
		this.game = game;
	}

	getTileAt(x, y) {
		return this.game.tiles.find(
			(tile) =>
				tile.x <= x &&
				tile.x + tile.width >= x &&
				tile.y <= y &&
				tile.y + tile.height >= y
		);
	}

	/**
	 *
	 * @param {Entity} entity
	 */
	updatePosition(entity) {
		entity.motion.y -= this.gravity;
		this.game.tiles.forEach((tile) => this.collide(entity, tile));
		let temp = entity.position.current.x;
		entity.position.current.x += entity.motion.x;
		entity.position.old.x = temp;

		temp = entity.position.current.y;
		entity.position.current.y += entity.motion.y;
		entity.position.old.y = temp;
	}

	/**
	 * @param {Entity} box1
	 * @param {Tile} box2
	 * @param {number} deltaX
	 * @param {number} deltaY
	 * @returns {boolean}
	 */
	isInside(box1, box2, deltaX, deltaY) {
		return (
			box1.position.current.x + box1.width + deltaX >= box2.x &&
			box1.position.current.x + deltaX <= box2.x + box2.width &&
			box1.position.current.y + box1.height + deltaY >= box2.y &&
			box1.position.current.y + deltaY <= box2.y + box2.height
		);
	}

	/**
	 *
	 * @param {Entity} box1
	 * @param {Tile} box2
	 * @returns {[string, Tile]}
	 */
	collide(box1, box2) {
		let A = [
			box1.position.current.x,
			box1.position.current.y,
			box1.width,
			box1.height,
		];
		let B = [box2.x, box2.y, box2.width, box2.height];

		let deltaX = box1.position.current.x - box1.position.old.x;
		let deltaY = box1.position.current.y - box1.position.old.y;

		if (this.isInside(box1, box2, deltaX, deltaY)) {
			if (
				Math.abs(A[0] - B[0]) - A[2] - B[2] >
					Math.abs(A[1] - B[1] + deltaX) - A[3] - B[3] &&
				(A[0] + A[2] - 10 <= B[0] || A[0] >= B[0] + B[2] + 10)
			) {
				return ["right", box2];
			} else {
				if (A[1] < B[1]) return ["top", box2];

				return ["bottom", box2];
			}
		}

		return ["none", box2];
	}
}

const levels = [
	[
		new Tile(0, 0, 1000, 100),
		new Tile(500, 100, 20, 75),
		new Tile(700, 150, 20, 1000),
		new Tile(900, 100, 100, 100),
		new Tile(1100, 200, 120, 25),
		new Tile(1400, 200, 200, 50),
		new Tile(1900, 50, 200, 50),
		new Tile(2200, 100, 500, 50),
		new Tile(2900, 100, 500, 50),
	],
	[
		new Tile(0, 0, 400, 100),
		new Tile(600, 0, 20, 100),
		new Tile(750, 0, 20, 200),
		new Tile(1000, 10, 340, 30),
		new Tile(1500, 100, 250, 40),
		new Tile(1500, 200, 175, 40),
		new Tile(1900, 200, 500, 20),
		new Tile(2675, 0, 100, 100),
		new Tile(2925, 0, 1200, 100),
		new Tile(3150, 100, 20, 85),
		new Tile(3150, 300, 20, 400),
		new Tile(3300, 175, 20, 600),
		new Tile(3425, 100, 20, 70),
	],
];

class BaseGame {
	task;
	/** @type {Physics} */
	physics;

	/** @type {Entity[]} */
	entities = [];
	/** @type {Tile[]} */
	tiles = [];

	/**
	 * @private
	 * @type {function(BaseGame)}
	 */
	tickListener;

	/**
	 * @private
	 * @type {number}
	 */
	tickBase;

	/**
	 *
	 * @param {Entity[]} entities
	 * @param {Tile[]} tiles
	 */
	constructor(entities, tiles) {
		this.physics = new Physics(this);
		this.entities = entities;
		this.tiles = tiles;
		this.tickListener = () => {};
	}

	start() {
		this.tickBase = setInterval(() => {
			this.tickListener(this);
		}, 1);
	}

	/**
	 *
	 * @param {function(BaseGame)} callback
	 */
	onTick(callback) {
		this.tickListener = callback;
	}

	end() {
		clearInterval(this.tickBase);
	}
}
